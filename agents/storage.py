import aiosqlite
import json
import asyncio
from datetime import datetime

DB_PATH = "bot_data_v2.db"

# -------------------------------------------------------------
#  DATABASE INIT
# -------------------------------------------------------------
async def init_db():
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("PRAGMA foreign_keys = ON;")
        
        await db.executescript("""
        CREATE TABLE IF NOT EXISTS threads (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );

        -- Unified Messages Table (User, Assistant, System)
        CREATE TABLE IF NOT EXISTS messages (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            thread_id INTEGER NOT NULL,
            role TEXT NOT NULL,       -- 'user', 'assistant', 'system'
            content TEXT,             -- The text content (can be null if only calling a tool)
            sequence INTEGER NOT NULL, -- To guarantee strict ordering
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY(thread_id) REFERENCES threads(id) ON DELETE CASCADE
        );

        -- Unified Tool Table (Stores both Input Arguments and Output Results)
        CREATE TABLE IF NOT EXISTS ai_tool_calls (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message_id INTEGER NOT NULL,  -- The AI message that triggered this call
            call_id TEXT,                 -- The unique ID provided by the LLM (e.g., call_abc123)
            tool_input_json JSON NOT NULL,      -- INPUT: The arguments generated by AI
            tool_output JSON,             -- OUTPUT: The result from the actual function (Nullable until run)
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY(message_id) REFERENCES messages(id) ON DELETE CASCADE
        );
        """)
        await db.commit()
        print("Database initialized successfully.")

# -------------------------------------------------------------
#  INTERNAL UTILITY
# -------------------------------------------------------------
async def _get_next_sequence(db, thread_id: int) -> int:
    row = await db.execute(
        "SELECT COALESCE(MAX(sequence), 0) + 1 FROM messages WHERE thread_id = ?",
        (thread_id,)
    )
    return (await row.fetchone())[0]

# -------------------------------------------------------------
#  THREAD OPERATIONS
# -------------------------------------------------------------
async def create_thread(title: str = "New Chat") -> int:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("INSERT INTO threads (title) VALUES (?)", (title,))
        await db.commit()
        return cur.lastrowid

# -------------------------------------------------------------
#  MESSAGE OPERATIONS
# -------------------------------------------------------------
async def add_message(thread_id: int, role: str, content: str = None) -> int:
    """
    Adds a text message. If this message also triggers tools, 
    use the returned ID with `add_tool_call`.
    """
    async with aiosqlite.connect(DB_PATH) as db:
        seq = await _get_next_sequence(db, thread_id)
        cur = await db.execute("""
            INSERT INTO messages (thread_id, role, content, sequence)
            VALUES (?, ?, ?, ?)
        """, (thread_id, role, content, seq))
        await db.commit()
        return cur.lastrowid

# -------------------------------------------------------------
#  TOOL OPERATIONS (Unified Input/Output)
# -------------------------------------------------------------
async def add_tool_call(message_id: int, tool_input_json: dict, call_id: str = None) -> int:
    """
    Registers that the AI wants to call a tool. 
    call_id is optional but recommended if using OpenAI (they return unique IDs).
    """
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("""
            INSERT INTO ai_tool_calls (message_id, call_id, tool_input_json)
            VALUES (?, ?, ?)
        """, (message_id, call_id, json.dumps(tool_input_json)))
        await db.commit()
        return cur.lastrowid

async def update_tool_result(message_id: int, call_id: str, tool_output: dict):
    """
    Updates the existing tool call row with the result.
    """
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            UPDATE ai_tool_calls 
            SET tool_output = ? 
            WHERE message_id = ? AND call_id = ?
        """, (json.dumps(tool_output), message_id, call_id))
        await db.commit()

# -------------------------------------------------------------
#  CHAT RECONSTRUCTION (The Magic Part)
# -------------------------------------------------------------
async def get_full_thread(thread_id: int):
    """
    Reconstructs the conversation.
    It fetches messages, then attaches any associated tool inputs/outputs.
    """
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row  # Allows accessing columns by name

        # 1. Get all messages with any joined tool calls
        cursor = await db.execute(
            """
            SELECT 
                messages.id AS message_id,
                messages.role,
                messages.content,
                messages.created_at AS message_created_at,
                messages.sequence AS message_sequence,
                ai_tool_calls.created_at AS tool_call_created_at,
                ai_tool_calls.call_id AS tool_call_id,
                ai_tool_calls.tool_input_json AS tool_tool_input_json,
                ai_tool_calls.tool_output AS tool_tool_output
            FROM messages 
            LEFT JOIN ai_tool_calls ON messages.id = ai_tool_calls.message_id
            WHERE messages.thread_id = ?
            ORDER BY messages.created_at ASC, ai_tool_calls.created_at ASC
            """,
            (thread_id,),
        )

        rows = await cursor.fetchall()

        # 2. Group tool calls by message, preserving created_at ordering
        messages_by_id = {}
        order = []  # maintain message order by created_at
        for r in rows:
            message_id = r["message_id"]
            if message_id not in messages_by_id:
                messages_by_id[message_id] = {
                    "message_id": message_id,
                    "role": r["role"],
                    "content": r["content"],
                    "message_created_at": r["message_created_at"],
                    "sequence": r["message_sequence"],
                    "tool_calls": [],
                }
                order.append(message_id)

            # Append tool call if present (LEFT JOIN may yield NULLs)
            if r["tool_call_id"] is not None:
                tool_input = r["tool_tool_input_json"]
                # Decode only tool_input_json; tool_output may be any type
                if tool_input:
                    try:
                        tool_input = json.loads(tool_input)
                    except json.JSONDecodeError:
                        # leave as-is if not valid JSON
                        pass
                messages_by_id[message_id]["tool_calls"].append({
                    "call_id": r["tool_call_id"],
                    "tool_input_json": tool_input,
                    "tool_output": r["tool_tool_output"],
                    "created_at": r["tool_call_created_at"],
                })

        # 3. Build final list preserving message order
        final_history = [messages_by_id[mid] for mid in order]
        return final_history

# -------------------------------------------------------------
#  TESTING THE FLOW
# -------------------------------------------------------------
async def main():
    await init_db()
    
    # t_id = await create_thread("Weather Check")
    # print(f"Thread created: ID {t_id}")

    print(await get_full_thread(12))

if __name__ == "__main__":
    asyncio.run(main())