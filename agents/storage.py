import aiosqlite
import json
import asyncio
from datetime import datetime

DB_PATH = "bot_data_v2.db"

# -------------------------------------------------------------
#  DATABASE INIT
# -------------------------------------------------------------
async def init_db():
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("PRAGMA foreign_keys = ON;")
        
        await db.executescript("""
        CREATE TABLE IF NOT EXISTS threads (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );

        -- Unified Messages Table (User, Assistant, System)
        CREATE TABLE IF NOT EXISTS messages (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            thread_id INTEGER NOT NULL,
            role TEXT NOT NULL,       -- 'user', 'assistant', 'system'
            content TEXT,             -- The text content (can be null if only calling a tool)
            sequence INTEGER NOT NULL, -- To guarantee strict ordering
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY(thread_id) REFERENCES threads(id) ON DELETE CASCADE
        );

        -- Unified Tool Table (Stores both Input Arguments and Output Results)
        CREATE TABLE IF NOT EXISTS ai_tool_calls (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message_id INTEGER NOT NULL,  -- The AI message that triggered this call
            call_id TEXT,                 -- The unique ID provided by the LLM (e.g., call_abc123)
            input_json JSON NOT NULL,      -- INPUT: The arguments generated by AI
            output_json JSON,             -- OUTPUT: The result from the actual function (Nullable until run)
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY(message_id) REFERENCES messages(id) ON DELETE CASCADE
        );
        """)
        await db.commit()
        print("Database initialized successfully.")

# -------------------------------------------------------------
#  INTERNAL UTILITY
# -------------------------------------------------------------
async def _get_next_sequence(db, thread_id: int) -> int:
    row = await db.execute(
        "SELECT COALESCE(MAX(sequence), 0) + 1 FROM messages WHERE thread_id = ?",
        (thread_id,)
    )
    return (await row.fetchone())[0]

# -------------------------------------------------------------
#  THREAD OPERATIONS
# -------------------------------------------------------------
async def create_thread(title: str = "New Chat") -> int:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("INSERT INTO threads (title) VALUES (?)", (title,))
        await db.commit()
        return cur.lastrowid

# -------------------------------------------------------------
#  MESSAGE OPERATIONS
# -------------------------------------------------------------
async def add_message(thread_id: int, role: str, content: str = None) -> int:
    """
    Adds a text message. If this message also triggers tools, 
    use the returned ID with `add_tool_call`.
    """
    async with aiosqlite.connect(DB_PATH) as db:
        seq = await _get_next_sequence(db, thread_id)
        cur = await db.execute("""
            INSERT INTO messages (thread_id, role, content, sequence)
            VALUES (?, ?, ?, ?)
        """, (thread_id, role, content, seq))
        await db.commit()
        return cur.lastrowid

# -------------------------------------------------------------
#  TOOL OPERATIONS (Unified Input/Output)
# -------------------------------------------------------------
async def add_tool_call(message_id: int, input_json: dict, call_id: str = None) -> int:
    """
    Registers that the AI wants to call a tool. 
    call_id is optional but recommended if using OpenAI (they return unique IDs).
    """
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("""
            INSERT INTO ai_tool_calls (message_id, call_id, input_json)
            VALUES (?, ?, ?)
        """, (message_id, call_id, json.dumps(input_json)))
        await db.commit()
        return cur.lastrowid

async def update_tool_result(message_id: int, call_id: str, output_json: dict):
    """
    Updates the existing tool call row with the result.
    """
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            UPDATE ai_tool_calls 
            SET output_json = ? 
            WHERE message_id = ? AND call_id = ?
        """, (json.dumps(output_json), message_id, call_id))
        await db.commit()

# -------------------------------------------------------------
#  CHAT RECONSTRUCTION (The Magic Part)
# -------------------------------------------------------------
async def get_full_thread(thread_id: int):
    """
    Reconstructs the conversation.
    It fetches messages, then attaches any associated tool inputs/outputs.
    """
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row # Allows accessing columns by name
        
        # 1. Get all messages
        cursor = await db.execute("""
            SELECT id, role, content, sequence, created_at 
            FROM messages 
            WHERE thread_id = ? 
            ORDER BY sequence ASC
        """, (thread_id,))
        messages = await cursor.fetchall()
        
        final_history = []
        
        for msg in messages:
            msg_dict = dict(msg)
            
            # 2. Check if this message has associated tool calls
            tool_cursor = await db.execute("""
                SELECT id, call_id, input_json, output_json 
                FROM ai_tool_calls 
                WHERE message_id = ?
            """, (msg['id'],))
            
            tools = await tool_cursor.fetchall()
            
            if tools:
                # Add tool_calls list to the AI message
                msg_dict['tool_calls'] = []
                
                # We also need to represent the "Tool Result" messages for the LLM
                # Usually, these follow immediately after the AI message in the context window
                tool_results_to_append = []
                
                for tool in tools:
                    # Append Input (The AI's request)
                    msg_dict['tool_calls'].append({
                        "id": tool['call_id'],
                        "function": {
                            "arguments": json.loads(tool['input_json'])
                        },
                        "type": "function"
                    })
                    
                    # Check if we have a result yet. 
                    # If yes, we must synthesize the "tool" role message for the LLM history
                    if tool['output_json']:
                        tool_results_to_append.append({
                            "role": "tool",
                            "tool_call_id": tool['call_id'],
                            "content": tool['output_json'] # Kept as JSON string usually, or parsed
                        })

                final_history.append(msg_dict)
                
                # Append the synthesized tool results immediately after
                final_history.extend(tool_results_to_append)
                
            else:
                final_history.append(msg_dict)
                
        return final_history

# -------------------------------------------------------------
#  TESTING THE FLOW
# -------------------------------------------------------------
async def main():
    await init_db()
    
    t_id = await create_thread("Weather Check")
    print(f"Thread created: ID {t_id}")

if __name__ == "__main__":
    asyncio.run(main())